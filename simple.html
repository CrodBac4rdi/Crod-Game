<\!DOCTYPE html>
<html>
<head>
    <title>Cosmic Clicker - Simple Shell</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: Arial; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background: #0a0a0f; }
        #progress { width: 300px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; margin: 10px; }
        #progress-bar { height: 100%; background: linear-gradient(90deg, #00d4ff, #ff00ff); width: 0%; transition: width 0.3s; }
        #game-canvas { width: 100%; height: 100vh; display: none; }
        #ui { position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; }
        .error { color: #ff3366; margin: 10px; padding: 10px; background: #300; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="loading">
        <h1>COSMIC CLICKER 3D</h1>
        <div id="progress"><div id="progress-bar"></div></div>
        <div id="status">Starting...</div>
        <div id="error" style="display:none;"></div>
    </div>
    
    <canvas id="game-canvas"></canvas>
    <div id="ui" style="display:none;">
        <div>âš¡ <span id="energy">0</span></div>
        <div>ðŸ’Ž <span id="crystals">0</span></div>
    </div>

    <script>
class GameShell {
    constructor() {
        this.modules = {};
        this.progress = 0;
        this.progressBar = document.getElementById('progress-bar');
        this.statusText = document.getElementById('status');
        this.errorDiv = document.getElementById('error');
        console.log('GameShell initialized');
    }
    
    updateProgress(percent, message) {
        this.progress = percent;
        this.progressBar.style.width = percent + '%';
        this.statusText.textContent = message;
        console.log(`[${percent}%] ${message}`);
    }
    
    showError(message) {
        console.error('Error:', message);
        this.errorDiv.innerHTML = `<strong>Error:</strong> ${message}<br><button onclick="location.reload()">Reload</button>`;
        this.errorDiv.style.display = 'block';
    }
    
    async loadThreeJS() {
        return new Promise((resolve, reject) => {
            if (typeof THREE \!== 'undefined') {
                resolve();
                return;
            }
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js';
            script.onload = resolve;
            script.onerror = () => reject(new Error('THREE.js failed to load'));
            document.head.appendChild(script);
        });
    }
    
    createScene() {
        const canvas = document.getElementById('game-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.z = 30;
        
        // Create orb
        const geometry = new THREE.SphereGeometry(5, 32, 32);
        const material = new THREE.MeshPhongMaterial({ color: 0x00d4ff });
        const orb = new THREE.Mesh(geometry, material);
        scene.add(orb);
        
        // Lights
        scene.add(new THREE.AmbientLight(0x404040, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 5);
        scene.add(light);
        
        // Game state
        const gameState = { energy: 0, crystals: 0 };
        
        // Click handler
        canvas.addEventListener('click', () => {
            orb.scale.setScalar(1.2);
            setTimeout(() => orb.scale.setScalar(1), 100);
            gameState.energy++;
            document.getElementById('energy').textContent = gameState.energy;
        });
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            orb.rotation.y += 0.01;
            orb.position.y = Math.sin(Date.now() * 0.001) * 0.5;
            renderer.render(scene, camera);
        }
        
        animate();
        return { scene, camera, renderer, orb, gameState };
    }
    
    async start() {
        try {
            this.updateProgress(10, 'Loading THREE.js...');
            await this.loadThreeJS();
            
            this.updateProgress(50, 'Creating scene...');
            await new Promise(resolve => setTimeout(resolve, 100));
            this.modules.game = this.createScene();
            
            this.updateProgress(100, 'Ready\!');
            
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game-canvas').style.display = 'block';
                document.getElementById('ui').style.display = 'block';
            }, 500);
            
        } catch (error) {
            this.showError(error.message);
        }
    }
}

const gameShell = new GameShell();
window.addEventListener('DOMContentLoaded', () => gameShell.start());
window.addEventListener('error', (e) => gameShell.showError(e.message));
    </script>
</body>
</html>
ENDFILE < /dev/null
